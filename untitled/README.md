# part1 루틴과 코루틴

### 코루틴이란?

`co-routine`, 협력하는 루틴

### 루틴과 코루틴의 차이

```kotlin
fun main() {
    println("START")
    newRoutine()
    println("END")
}

fun newRoutine() {
    val num1 = 1
    val num2 = 2
    println("${num1 + num2}")
}
```

메모리 관점으로 보면 새로운 루틴이 호출되면, newRoutine이 사용하는 스택에

지역변수가 초기화되고 `루틴이 끝나면 해당 메모리에 접근이 불가능하다`

즉 루틴에 진입하는 곳이 한 군데이며, 종료되면 해당 루틴의 정보가 초기화된다

### 하지만 코루틴은!

협력하는 루틴(=코드 모음)

```kotlin
fun main() : Unit = runBlocking {
    println("START")
    launch { newRoutine() }
    yield()
    println("END")
}

suspend fun newRoutine(){
    val num1 = 1
    val num2 = 2
    yield()
    println("${num1 + num2}")
}
```

`runBlocking` - 일반루틴 세계와 코루틴 세계를 연결한다. 이 함수 자체로 `새로운 코루틴`을 만든다

`launch` - `반환값이 없는` 코루틴을 만든다

`suspend fun` - 다른 suspend fun을 호출할 수 있다

`yield` - 지금 코루틴을 중단하고 다른 코루틴이 실행되도록 한다 (스레드를 양보한다)

메모리 관점 : 새로운 루틴이 호출된 후, 완전히 종료되기 전, `해당 루틴에서 사용했던 정보들을 보관`하고 있어야 한다

`루틴이 중단되었다가 해당 메모리에 접근이 가능하다`

### 루틴과 코루틴의 차이 정리

`루틴` - 시작되면 끝날 때 까지 멈추지 않는다. 한 번 끝나면 루틴 내의 정보가 사라진다

`코루틴` - 중단되었다가 재개될 수 있다. 중단되더라도 루틴 내의 정보가 사라지지 않는다



# part2 스레드와 코루틴

### 프로세스

컴퓨터에서 실행되고 있는 프로그램

### 스레드

프로세스보다 작은 개념. 프로세스에 소속되어 여러 코드를 동시에 실행할 수 있게 해준다

### 스레드와 코루틴의 차이

프로세스가 스레드보다 큰 개념이듯이 스레드가 코루틴보다 큰 개념이다

`다만 스레드-코루틴을 프로세스-스레드에 빗대기에는 다른 점이 있다`

프로세스가 있어야만 스레드가 있을 수 있고 스레드가 프로세스를 바꿀 순 없다

코루틴의 코드가 실행되려면, 스레드가 있어야만한다

하지만, 중단되었다가 재개될 때 다른 스레드에 배정될 수 있다

스레드는 특정 프로세스에 종속되어 있지만 코루틴은 Thread에 종속되어 있는 개념이 아니라 코루틴의 코드를 어떤 스레드건 가져갈 수 있다

`context switching에서도 차이가 존재한다`

### 프로세스 context switching이 일어날 때 특징

프로세스는 독립된 메모리를 가지고 있다. 모든 메모리가 교체되므로 비용이 많이 발생

### 스레드 context switching이 일어날 때 특징

같은 프로세스에 소속되었기에 heap area를 공유하고 독립적인 stack area를 가진다. stack area만 교체되므로 프로세스보다 비용이 적게 발생

### 코루틴 context switching이 일어날 때 특징

동일 스레드에서 코루틴이 실행되면, 메모리 전부를 공유하므로 스레드보다 context switching cost가 낮다

하나의 스레드에서도 `동시성`을 확보할 수 있다

### 동시성

한번에 한가지 일만 할 수 있지만 아주 빠르게 작업이 전환되어 동시에 하는 것처럼 보이는 것을 의미

### 병렬성

실제로 2가지 일을 동시에 하는 것(CPU multi-core)

### 코루틴은 스스로 자리를 양보할 수 있다 (yield())

### 스레드와 코루틴의 차이 정리

1. 스레드는 프로세스보다 작은개념. 코루틴은 스레드보다 작은 개념
2. 한스레드는 오직 한 프로세스에만 포함되어 있다. 한 코루틴의 코드는 여러 스레드에서 실행될 수 있다
3. 스레드는 context switching발생시 stack영역이 교체. 코루틴은 (한스레드에서 실행되는경우 )context switchign시 메모리 교체가 없다
4. 스레드는 os가 스레드를 강제로 멈추고 다른 스레드를 실행한다. 코루틴은 스스로가 다른 코루틴에게 양보한다
